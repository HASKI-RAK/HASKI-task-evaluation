import { ServerEventPayload } from '@haski/ta-lib'
import { Button, FormControl, Stack, TextField, Typography } from '@mui/material'
import LinearProgress, { linearProgressClasses } from '@mui/material/LinearProgress'
import { styled } from '@mui/material/styles'
import { memo, useEffect, useState } from 'react'

interface MyThemeComponentProps {
  color?: 'primary' | 'secondary'
}

/**
 * based on value of successPercentage, the color of the progress bar changes
 */
const BorderLinearProgress = styled(LinearProgress, {
  overridesResolver: (props, styles) => [
    styles.root,
    props.color === 'primary' && styles.primary,
    props.color === 'secondary' && styles.secondary
  ]
})<MyThemeComponentProps>(({ theme }) => ({
  height: 10,
  borderRadius: 5,
  [`&.${linearProgressClasses.colorPrimary}`]: {
    backgroundColor: theme.palette.grey[theme.palette.mode === 'light' ? 200 : 800]
  },
  [`& .${linearProgressClasses.bar}`]: {
    borderRadius: 5,
    backgroundColor: theme.palette.mode === 'light' ? '#1a90ff' : '#308fe8'
  }
}))

const TaskView = ({
  onSubmit,
  outputs,
  maxInputChars = 300,
  question
}: {
  onSubmit: (answer: string) => void
  outputs?: Record<string, ServerEventPayload['output']>
  maxInputChars?: number
  question: string
}) => {
  const [error, setError] = useState<string | null>(null)
  const [answer, setAnswer] = useState<string>('')

  const handleSetAnswer = (event: React.ChangeEvent<HTMLInputElement>) => {
    validateAnswer()
    setAnswer(event.target.value)
  }

  const validateAnswer = (): boolean => {
    if (answer.length < 10) {
      setError('Answer must be at least 10 characters long')
      return false
    } else if (answer.length > maxInputChars) {
      // TODO: find optimal length based on literature
      // to ensure the user doesnt paste a lot of text containing the answer
      setError('Answer must be at most ' + maxInputChars + ' characters long')
      return false
    } else {
      setError(null)
      return true
    }
  }

  const keyDownHandlerCtrlEnter = (event: KeyboardEvent): void => {
    if (event.ctrlKey && event.key === 'Enter') {
      console.log('ctrl+enter')
      validateAnswer()
    }
  }

  const handleSubmit = (event?: React.FormEvent<HTMLFormElement>): void => {
    event?.preventDefault()
    validateAnswer()
    onSubmit(answer)
  }

  useEffect(() => {
    console.log('Task view rendered with output: ', outputs ?? 'no output')
    document.addEventListener('keydown', keyDownHandlerCtrlEnter)
    return () => {
      document.removeEventListener('keydown', keyDownHandlerCtrlEnter)
    }
  }, [outputs])

  return (
    <Stack spacing={2} margin={2}>
      <Typography variant="h4">Aufgabe:</Typography>
      <Typography
        style={{
          maxWidth: '60rem' // Set a maximum width
        }}
        variant="body1"
      >
        {question}
      </Typography>
      <form
        onSubmit={handleSubmit}
        noValidate
        autoComplete="off"
        style={{ width: '100%' }}
      >
        <FormControl fullWidth error={!!error}>
          <Stack spacing={2}>
            <TextField
              id="outlined-multiline-static"
              label="Answer"
              multiline
              error={!!error}
              helperText={error}
              rows={6}
              placeholder="Write your answer here"
              onChange={handleSetAnswer}
            />
            <Button variant="contained" type="submit" onClick={() => handleSubmit()}>
              Submit
            </Button>
            {/* Map over all outputs and display them */}
            {outputs &&
              Object.values(outputs).map((out) => {
                console.log('output: ', out)
                switch (out.type) {
                  case 'text':
                    return (
                      <>
                        <Typography variant="h6">{out.label}</Typography>
                        <Typography
                          style={{
                            maxWidth: '50rem' // Set a maximum width
                          }}
                          variant="body1"
                        >
                          {out.value}
                        </Typography>
                        <Typography variant="body2">
                          Please note that answered generated by the system may be
                          incorrect or contain misleading information.
                        </Typography>
                      </>
                    )
                  case 'score':
                    // assert that output.value is a number
                    if (typeof out.value !== 'number') {
                      console.error(
                        'output.value is not a number, but of type: ',
                        typeof out.value
                      )
                      return null
                    }
                    return (
                      <>
                        <Typography variant="h6">
                          {out.label}: {out.value}
                        </Typography>
                        {out.value >= 0 && out.value <= 100 && (
                          <BorderLinearProgress variant="determinate" value={out.value} />
                        )}
                      </>
                    )
                  case 'classifications':
                    // assert that output.value is an array of strings
                    if (!Array.isArray(out.value)) {
                      console.error(
                        'output.value is not an array, but of type: ',
                        typeof out.value
                      )
                      return null
                    }
                    // display chips with classifications
                    return (
                      <>
                        <Typography variant="h6">Classifications:</Typography>
                        {out.value.map((classification) => (
                          <Typography variant="body1" key={classification}>
                            {classification}
                          </Typography>
                        ))}
                      </>
                    )
                }
              })}
          </Stack>
        </FormControl>
      </form>
    </Stack>
  )
}
export default memo(TaskView)
